snippet f "f(x,y)=x+y"
${1:f(* name *)}(${2:* args *}) = ${3:* body *}
endsnippet

snippet fun "function"
function ${1:f}(${2:args...})
    ${3:(* body *)}
    return ${4:(* results *)}
end
endsnippet
snippet if "if ... elseif ... else ... "
if ${1:(* condition 1*)} 
   return ${2:(* A *)}
elseif ${3:(* condition 2)}
   return ${4:(* B *)}
else
   return ${5:(* C *)}
end
endsnippet
snippet map "map"
map(${1:(* x *)} -> ${2:(* y *)}
endsnippet
#snippet If "if ... else ..."
#if ${1:(* condition *)} 
#   return ${2:(* A *)}
#else
#   return ${3:(* B *)}
#end
#endsnippet
snippet If "a ? b : c"
${1:(* condition *)} ? ${2:(* A *)} : ${3:(* B *)}
endsnippet

snippet map "map"
map(${1:(* x *)} -> ${2:(* y *)}
endsnippet

snippet for " for i=1:10"
for ${1:i} = ${2:1}:${3:end}
  ${4:(* body *)}  
end
endsnippet 
# comprehension [1:5] |> x->x.^2 |> sum |> inv
snippet ff "[(x,y) for x in 1:5, y in 5:10]"
[ ${1:(* expr *)} for ${2:x} in ${3:1}:${4:end}, ${5:y} in ${6:1}:${7:end} ]
endsnippet 

snippet For "for i in [1,2,3]"
for ${1:i} in ${2:[1,2,3]}
  ${3:(* body *)}
end
endsnippet
snippet while "while ..."
while ${1:(* condition *)}
  ${2:(* body *)}
end
endsnippet
snippet begin "begin ... end"
${1:z} = begin
       ${2:(* expr 1 *)}
       ${3:(* expr 2 *)}
end
endsnippet
snippet Begin "z = (x = 1; y = 2; z = x+y)"
${1:z} = (${2:(* expr1 *)};${3:(* expr2 *)})
endsnippet

snippet cc "call c or fortran library"
${1:f} = ccall((:${2:fun}, "${3:lib}"), ${4:(* Return Type *)}, (${5:(* Input Types *)}), ${6:(* Input Args *)})
endsnippet
snippet module "module"
module ${1:Name}
include("${2:Module Name}.jl")
end
endsnippet
snippet para "@parallel"
${1:(*vars*)} = @parallel (${2:+}) for ${3:i}=${4:1}:${5:10}
  ${6:(*body*)}
end
endsnippet
snippet broadcast "broadcast"
broadcast(${1:+}, ${2:a}, ${3:A})
endsnippet
snippet macro "macro"
macro ${1:(*name*)}(${2:(*args*)})
  quote
	${3:(*body*)}  
  end
end
endsnippet
snippet test "test"
@test ${1:(*expr left*)} ${2:==} ${3:(*expr right*)}
endsnippet
snippet test "test_approx_equal"
@test_approx_eq ${1:(*expr 1*)} ${2:(*expr 2*)}
endsnippet
snippet test "test_approx_equal_eps"
@test_approx_eq_eps ${1:(*expr 1*)} ${2:(*expr 2*)} ${3:eps}
endsnippet
snippet type "type"
type ${1:TypeName}
  ${2:(Types)}
end
endsnippet
